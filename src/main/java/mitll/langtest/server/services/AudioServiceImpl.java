/*
 *
 * DISTRIBUTION STATEMENT C. Distribution authorized to U.S. Government Agencies
 * and their contractors; 2015. Other request for this document shall be referred
 * to DLIFLC.
 *
 * WARNING: This document may contain technical data whose export is restricted
 * by the Arms Export Control Act (AECA) or the Export Administration Act (EAA).
 * Transfer of this data by any means to a non-US person who is not eligible to
 * obtain export-controlled data is prohibited. By accepting this data, the consignee
 * agrees to honor the requirements of the AECA and EAA. DESTRUCTION NOTICE: For
 * unclassified, limited distribution documents, destroy by any method that will
 * prevent disclosure of the contents or reconstruction of the document.
 *
 * This material is based upon work supported under Air Force Contract No.
 * FA8721-05-C-0002 and/or FA8702-15-D-0001. Any opinions, findings, conclusions
 * or recommendations expressed in this material are those of the author(s) and
 * do not necessarily reflect the views of the U.S. Air Force.
 *
 * Â© 2015 Massachusetts Institute of Technology.
 *
 * The software/firmware is provided to you on an As-Is basis
 *
 * Delivered to the US Government with Unlimited Rights, as defined in DFARS
 * Part 252.227-7013 or 7014 (Feb 2014). Notwithstanding any copyright notice,
 * U.S. Government rights in this work are defined by DFARS 252.227-7013 or
 * DFARS 252.227-7014 as detailed above. Use of this work other than as specifically
 * authorized by the U.S. Government may violate any copyrights that exist in this work.
 *
 *
 */

package mitll.langtest.server.services;

import mitll.langtest.client.services.AudioService;
import mitll.langtest.server.ServerProperties;
import mitll.langtest.server.audio.AudioCheck;
import mitll.langtest.server.audio.AudioFileHelper;
import mitll.langtest.server.audio.PathWriter;
import mitll.langtest.server.audio.TrackInfo;
import mitll.langtest.server.audio.image.ImageType;
import mitll.langtest.server.audio.imagewriter.SimpleImageWriter;
import mitll.langtest.server.database.AnswerInfo;
import mitll.langtest.server.database.Database;
import mitll.langtest.server.database.audio.AudioInfo;
import mitll.langtest.server.database.audio.EnsureAudioHelper;
import mitll.langtest.server.database.audio.IEnsureAudioHelper;
import mitll.langtest.server.database.custom.UserListManager;
import mitll.langtest.server.database.exercise.Project;
import mitll.langtest.server.database.project.IProjectManagement;
import mitll.langtest.server.database.security.NPUserSecurityManager;
import mitll.langtest.shared.answer.AudioAnswer;
import mitll.langtest.shared.answer.AudioType;
import mitll.langtest.shared.common.DominoSessionException;
import mitll.langtest.shared.exercise.*;
import mitll.langtest.shared.image.ImageResponse;
import mitll.langtest.shared.project.SlimProject;
import mitll.langtest.shared.project.StartupInfo;
import mitll.langtest.shared.scoring.AudioContext;
import mitll.langtest.shared.scoring.DecoderOptions;
import mitll.langtest.shared.scoring.ImageOptions;
import mitll.langtest.shared.user.MiniUser;
import mitll.langtest.shared.user.User;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.io.File;
import java.util.*;

/**
 * does image generation here too - since it's done from a file.
 */
@SuppressWarnings("serial")
public class AudioServiceImpl extends MyRemoteServiceServlet implements AudioService {
  private static final Logger logger = LogManager.getLogger(AudioServiceImpl.class);

  private static final int WARN_THRESH = 10;
  public static final String UNKNOWN = "unknown";
  private static final String FAST = "regular";
  private static final String SLOW = "slow";

  private PathWriter pathWriter;
  private IEnsureAudioHelper ensureAudioHelper;

  /**
   * Sanity checks on answers and bestAudio dir
   */
  @Override
  public void init() {
    super.init();
    pathWriter = new PathWriter(serverProps);
    ensureAudioHelper = new EnsureAudioHelper(db, pathHelper);
    pathWriter.doSanityCheckOnDir(new File(serverProps.getAnswerDir()), " answers dir ");
  }

  /**
   * Record an answer entry in the database.<br></br>
   * Write the posted data to a wav and an mp3 file (since all the browser audio works with mp3).
   * <p>
   * A side effect is to set the first state to UNSET if it was APPROVED
   * and to set the second state (not really used right now) to RECORDED
   * <p>
   * <p>
   * Wade has observed that audio normalization really messes up the ASR -- silence doesn't appear as silence after you multiply
   * the signal.  Also, the user doesn't get feedback that their mic gain is too high/too low or that they
   * are speaking too softly or too loudly
   * <p>
   * Client references below:
   *
   * @param base64EncodedString generated by flash on the client
   * @param recordedWithFlash   mark if we recorded it using flash recorder or webrtc
   * @param deviceType
   * @param device
   * @return AudioAnswer object with information about the audio on the server, including if audio is valid (not too short, etc.)
   * @paramx doFlashcard         true if called from practice (flashcard) and we want to do decode and not align
   * @paramx recordInResults     if true, record in results table -- only when recording in a learn or practice tab
   * @paramx addToAudioTable     if true, add to audio table -- only when recording reference audio for an item.
   * @paramx allowAlternates
   * @see mitll.langtest.client.scoring.PostAudioRecordButton#stopRecording
   * @see mitll.langtest.client.recorder.RecordButtonPanel#stopRecording
   */
  @Override
  public AudioAnswer writeAudioFile(String base64EncodedString,
                                    AudioContext audioContext,

                                    boolean recordedWithFlash,
                                    String deviceType,
                                    String device,
                                    DecoderOptions decoderOptions
  ) throws DominoSessionException {
    int projectID = getProjectIDFromUser();
    Project project = db.getProject(projectID);
    boolean hasProjectSpecificAudio = project.hasProjectSpecificAudio();
    AudioFileHelper audioFileHelper = getAudioFileHelper(project);

    int exerciseID = audioContext.getExid();
    boolean isExistingExercise = exerciseID > 0;

//    if (true) throw new IllegalArgumentException("testing exception handling...");
/*
    logger.info("writeAudioFile got " +
        "\n\trequest         " + audioContext +
        "\n\tdo flashcard    " + doFlashcard +
        "\n\trecordInResults " + recordInResults +
        "\n\taddToAudioTable " + addToAudioTable +
        "\n\tallowAlternates " + allowAlternates +
        "\n\tpayload bytes   " + base64EncodedString.length());
*/

    if (decoderOptions.isRefRecording() && !decoderOptions.isRecordInResults()) { // we have a foreign key from audio into result table - must record in results
      decoderOptions.setRecordInResults(true);
    }
    boolean amas = serverProps.isAMAS();

    CommonExercise commonExercise = amas || isExistingExercise ?
        db.getCustomOrPredefExercise(projectID, exerciseID) :
        db.getUserExerciseDAO().getTemplateExercise(db.getProjectDAO().getDefault());

    int audioContextProjid = audioContext.getProjid();

    if (audioContextProjid != projectID)
      logger.error("huh? session project " + projectID + " vs " + audioContextProjid);

    String language = db.getProject(audioContextProjid).getLanguage();

    if (!isExistingExercise) {
      ((Exercise) commonExercise).setProjectID(audioContextProjid);
      audioContext.setExid(commonExercise.getID());
    }

    CommonShell exercise1 = amas ? db.getAMASExercise(exerciseID) : commonExercise;

    if (exercise1 == null && isExistingExercise) {
      logger.warn("writeAudioFile " + getLanguage() + " : couldn't find exerciseID with id '" + exerciseID + "'");
    }
    String audioTranscript = getAudioTranscript(audioContext.getAudioType(), commonExercise);
    AnswerInfo.RecordingInfo recordingInfo = new AnswerInfo.RecordingInfo("", "", deviceType, device, recordedWithFlash, audioTranscript);

//    logger.info("writeAudioFile recording info " + recordingInfo);
    AudioAnswer audioAnswer =
        //amas ?
        //audioFileHelper.writeAMASAudioFile(base64EncodedString, db.getAMASExercise(exerciseID), audioContext, recordingInfo) :
        audioFileHelper.writeAudioFile(
            base64EncodedString,
            commonExercise,
            audioContext,
            recordingInfo,

            decoderOptions);

//    logger.info("writeAudioFile recording audioAnswer transcript '" + audioAnswer.getTranscript() + "'");
    int user = audioContext.getUserid();

    if (decoderOptions.isRefRecording() && audioAnswer.isValid()) {
      audioAnswer.setAudioAttribute(addToAudioTable(user, audioContext.getAudioType(), commonExercise, exerciseID, audioAnswer, hasProjectSpecificAudio));
    } //else {
    // So Wade has observed that this really messes up the ASR -- silence doesn't appear as silence after you multiply
    // the signal.  Also, the user doesn't get feedback that their mic gain is too high/too low or that they
    // are speaking too softly or too loudly.

    // normalizeLevel(audioAnswer);
    // }

    try {
      if (!audioAnswer.isValid() && audioAnswer.getDurationInMillis() == 0) {
        logger.warn("huh? got zero length recording " + user + " " + exerciseID);
        logEvent("audioRecording",
            "writeAudioFile", "" + exerciseID, "Writing audio - got zero duration!", user, device, projectID);
      } else {
        String path = audioAnswer.getPath();
        String actualPath = ensureAudioHelper.ensureCompressedAudio(user, commonExercise, path, audioContext.getAudioType(), language, new HashMap<>());
        logger.info("writeAudioFile initial path " + path + " compressed actual " + actualPath);
        if (actualPath.startsWith(serverProps.getAudioBaseDir())) {
          actualPath = actualPath.substring(serverProps.getAudioBaseDir().length());
          // logger.info("Now " + actualPath);
        }
        audioAnswer.setPath(actualPath);
//        logger.info("wrote compressed...");
      }
    } catch (Exception e) {
      logger.error("Got " + e, e);
    }


    return audioAnswer;
  }

  private MiniUser.Gender getGender(int user) {
    User byID = db.getUserDAO().getByID(user);
    return byID == null ? MiniUser.Gender.Unspecified : byID.getRealGender();
  }

  /**
   * Kick off a thread to do this... so we can return.
   */
 /* public void ensureAllAudio() {
    new Thread(() -> db.getProjects().forEach(project -> checkAudio(project.getID()))).start();
  }*/

  /**
   * @param projectid
   * @see mitll.langtest.client.project.ProjectEditForm#getCheckAudio
   */
  @Override
  public void checkAudio(int projectid) {
    Project project = db.getProject(projectid);
    logger.info("checkAudio - for project " + projectid + " " + project);
    long then = System.currentTimeMillis();
    db.getAudioDAO().makeSureAudioIsThere(projectid, project.getLanguage(), true);
    long now = System.currentTimeMillis();
    if (now - then > WARN_THRESH) {
      logger.info("checkAudio : for project " + projectid + " " + project +
          " - took " + (now - then) + " millis to check audio");
    }

    new Thread(() -> ensureAudioHelper.ensureAudio(projectid)).start();
  }

  private void logEvent(String id, String widgetType, String exid, String context, int userid, String device, int projID) {
    try {
      db.logEvent(id, widgetType, exid, context, userid, device, projID);
    } catch (Exception e) {
      logger.error("got " + e, e);
    }
  }

  /**
   * Remember this audio as reference audio for this exercise, and possibly clear the APRROVED (inspected) state
   * on the exercise indicating it needs to be inspected again (we've added new audio).
   * <p>
   * Don't return a path to the normalized audio, since this doesn't let the recorder have feedback about how soft
   * or loud they are : https://gh.ll.mit.edu/DLI-LTEA/Development/issues/601
   *
   * @param user                    who recorded audio
   * @param audioType               regular or slow
   * @param exercise1               for which exercise - how could this be null?
   * @param exerciseID              perhaps sometimes we want to override the exercise id?
   * @param audioAnswer             holds the path of the temporary recorded file
   * @param hasProjectSpecificAudio
   * @return AudioAttribute that represents the audio that has been added to the exercise
   * @paramx realGender
   * @see #writeAudioFile
   */
  private AudioAttribute addToAudioTable(int user,
                                         AudioType audioType,
                                         CommonExercise exercise1,
                                         int exerciseID,
                                         AudioAnswer audioAnswer,
                                         boolean hasProjectSpecificAudio) {
    boolean noExistingExercise = exercise1 == null;
    int idToUse = noExistingExercise ? exerciseID : exercise1.getID();
    int projid = noExistingExercise ? -1 : exercise1.getProjectID();
    String audioTranscript = audioAnswer.getTranscript();
    String language = db.getProject(projid).getLanguage();
    //   logger.debug("addToAudioTable user " + user + " ex " + exerciseID + " for " + audioType + " path before " + audioAnswer.getPath());

    File absoluteFile = pathHelper.getAbsoluteAudioFile(audioAnswer.getPath());
    boolean isContext = audioType == AudioType.CONTEXT_REGULAR || audioType == AudioType.CONTEXT_SLOW;
    String context = noExistingExercise ? "" : isContext ? getEnglish(exercise1) : exercise1.getEnglish();

    if (!absoluteFile.exists()) logger.error("addToAudioTable huh? no file at " + absoluteFile.getAbsolutePath());
    String permanentAudioPath = pathWriter.
        getPermanentAudioPath(
            absoluteFile,
            getPermanentName(user, audioType),
            true,
            language,
            idToUse,
            //audioTranscript,
            serverProps,
            new TrackInfo(audioTranscript, getArtist(user), context, language));

    AudioAttribute audioAttribute = null;
    try {
      MiniUser.Gender realGender = getGender(user);

      AudioInfo info = new AudioInfo(user, idToUse, projid, audioType, permanentAudioPath, System.currentTimeMillis(),
          audioAnswer.getDurationInMillis(), audioTranscript, (float) audioAnswer.getDynamicRange(), audioAnswer.getResultID(),
          realGender, hasProjectSpecificAudio);

      audioAttribute = db.getAudioDAO().addOrUpdate(info);

      audioAnswer.setPath(audioAttribute.getAudioRef());
      logger.debug("addToAudioTable" +
          "\n\tuser " + user +
          "\n\tex " + exerciseID + "/" + idToUse +
          "\n\tfor " + audioType +
          "\n\taudio answer has " + audioAttribute);

      // what state should we mark recorded audio?
      setExerciseState(idToUse, user, exercise1);
    } catch (Exception e) {
      logger.error("got " + e, e);
    }
    return audioAttribute;
  }

  private String getEnglish(CommonExercise exercise1) {
    return exercise1.isContext() ? exercise1.getEnglish() : exercise1.getDirectlyRelated().iterator().next().getEnglish();
  }

  private String getAudioTranscript(AudioType audioType, CommonExercise exercise1) {
    return exercise1 == null ? "" :
        audioType.equals(AudioAttribute.CONTEXT_AUDIO_TYPE) ? exercise1.getContext() : exercise1.getForeignLanguage();
  }

  private String getPermanentName(int user, AudioType audioType) {
    return audioType.toString() + "_" + System.currentTimeMillis() + "_by_" + user + ".wav";
  }

  private String getArtist(int user) {
    User userWhere = db.getUserDAO().getUserWhere(user);
    return userWhere == null ? "" + user : userWhere.getUserID();
  }

  private File getAbsoluteFile(String path) {
    return pathHelper.getAbsoluteFile(path);
  }

  /**
   * Only change APPROVED to UNSET.
   *
   * @param exercise
   * @param user
   * @param exercise1
   */
  private void setExerciseState(int exercise, int user, Shell exercise1) {
    if (exercise1 != null) {
      STATE currentState = db.getStateManager().getCurrentState(exercise);
      if (currentState == STATE.APPROVED) { // clear approved on new audio -- we need to review it again
        db.getStateManager().setState(exercise1, STATE.UNSET, user);
      }
      db.getStateManager().setSecondState(exercise1, STATE.RECORDED, user);
    }
  }

  /**
   * TODO : pass in language so we can switch on language
   * <p>
   * Get an image of desired dimensions for the audio file - only for Waveform and spectrogram.
   * Also returns the audio file duration -- so we can deal with the difference in length between mp3 and wav
   * versions of the same audio file.  (The browser soundmanager plays mp3 and reports audio offsets into
   * the mp3 file, but all the images are generated from the shorter wav file.)
   * <p>
   * TODO : Worrying about absolute vs relative path is maddening.  Must be a better way!
   *
   * @param reqid
   * @param audioFile
   * @param imageType
   * @param imageOptions
   * @param exerciseID
   * @return path to an image file
   * @see mitll.langtest.client.scoring.AudioPanel#getImageURLForAudio
   */
  public ImageResponse getImageForAudioFile(int reqid,
                                            String audioFile,
                                            String imageType,
                                            ImageOptions imageOptions,
                                            String exerciseID,
                                            String language) {
    if (audioFile.isEmpty())
      logger.error("getImageForAudioFile huh? audio file is empty for req id " + reqid + " exid " + exerciseID);

    SimpleImageWriter imageWriter = new SimpleImageWriter();

    String wavAudioFile = ensureAudioHelper.getWavAudioFile(audioFile, language);
    File testFile = new File(wavAudioFile);
    if (!testFile.exists() || testFile.length() == 0) {
      if (!testFile.exists()) {
        logger.error("getImageForAudioFile no audio at " + testFile.getAbsolutePath());
      } else if (testFile.length() == 0) {
        logger.error("getImageForAudioFile : huh? " + wavAudioFile + " is empty???");
      }
      return new ImageResponse();
    }
    ImageType imageType1 =
        imageType.equalsIgnoreCase(ImageType.WAVEFORM.toString()) ?
            ImageType.WAVEFORM :
            imageType.equalsIgnoreCase(ImageType.SPECTROGRAM.toString()) ?
                ImageType.SPECTROGRAM : null;
    if (imageType1 == null) {
      logger.error("getImageForAudioFile '" + imageType + "' is unknown?");
      return new ImageResponse(); // success = false!
    }
//    if (DEBUG || true) {
//      logger.debug("getImageForAudioFile : getting images (" + width + " x " + height + ") (" + reqid + ") type " + imageType +
//          " for " + wavAudioFile + "");
//    }

    long then = System.currentTimeMillis();

    String imageOutDir = pathHelper.getImageOutDir(language.toLowerCase());
    File absoluteImageDir = /*new File(language.toLowerCase(), imageOutDir);*/ getAbsoluteFile(imageOutDir);

    logger.info("getImageForAudioFile" +
        "\n\timageOutDir " + imageOutDir +
        "\n\tabs         " + absoluteImageDir +
        "\n\ttype        " + imageType1 +
        "\n\twavAudioFile " + wavAudioFile +
        "\n\ttestFile " + testFile +
        "\n\ttestFile len " + testFile.length()
    );
    String absolutePathToImage = imageWriter.writeImage(
        wavAudioFile,
        absoluteImageDir.getAbsolutePath(),
        imageOptions.getWidth(), imageOptions.getHeight(), imageType1, exerciseID);
    long now = System.currentTimeMillis();
    long diff = now - then;
    if (diff > WARN_THRESH) {
      logger.debug("getImageForAudioFile : got images " +
          // "(" + width + " x " + height + ")" +
          " (" + reqid + ") type " + imageType +
          "\n\tfor wav " + wavAudioFile +
          "\n\timage   " + absolutePathToImage +
          "\n\ttook    " + diff + " millis");
    }
    String installPath = pathHelper.getInstallPath();

    String relativeImagePath = absolutePathToImage;
    if (absolutePathToImage.startsWith(installPath)) {
      relativeImagePath = absolutePathToImage.substring(installPath.length());
    } else {
      logger.error("getImageForAudioFile huh? file path " + absolutePathToImage + " doesn't start with " + installPath + "?");
    }

    relativeImagePath = pathHelper.ensureForwardSlashes(relativeImagePath);
    if (relativeImagePath.startsWith("/")) {
      relativeImagePath = relativeImagePath.substring(1);
    }
    String imageURL = relativeImagePath;
    double duration = new AudioCheck(serverProps.shouldTrimAudio(), serverProps.getMinDynamicRange()).getDurationInSeconds(wavAudioFile);
    if (duration == 0) {
      logger.error("huh? " + wavAudioFile + " has zero duration???");
    }

    logger.debug("getImageForAudioFile for" +
        "\n\taudio file " + wavAudioFile +
        "\n\ttype       " + imageType +
        "\n\trel path   " + relativeImagePath +
        "\n\turl        " + imageURL +
        "\n\tduration   " + duration);

    return new ImageResponse(reqid, imageURL, duration);
  }

  public void recalcRefAudio(int projid) {
    db.getProject(projid).recalcRefAudio();
  }

  /**
   * Here so it's easy to test all the servers...
   *
   * @param subject
   * @param message
   * @param sendEmail
   */
  public void logMessage(String subject, String message, boolean sendEmail) {
    if (message.length() > 10000) message = message.substring(0, 10000);
    String prefixedMessage = "on " + getHostName() + " from client : " + message;

    prefixedMessage = getInfo(prefixedMessage);
    if (sendEmail) {
      logger.error(prefixedMessage);
    } else {
      logger.info(prefixedMessage);
    }

    if (sendEmail) {
      sendEmail("TEST : " + subject, getInfo(prefixedMessage));
    }
  }

  @Override
  public StartupInfo getStartupInfo() {
    List<SlimProject> projectInfos = new ArrayList<>();
    if (db == null) {
      logger.info("getStartupInfo no db yet...");
    } else {
      IProjectManagement projectManagement = db.getProjectManagement();
      ((NPUserSecurityManager) securityManager).setProjectManagement(projectManagement);
      if (projectManagement == null) {
        logger.error("getStartupInfo : config error - didn't make project management");
      } else {
        long then = System.currentTimeMillis();
        projectInfos = projectManagement.getNestedProjectInfo();
        long now = System.currentTimeMillis();
        if (now - then > 50L)
          logger.info("getStartupInfo took " + (now - then) + " millis to get nested projects.");
      }
    }

    //long then = System.currentTimeMillis();
    StartupInfo startupInfo =
        new StartupInfo(serverProps.getUIProperties(), projectInfos, "server", serverProps.getAffiliations());
//    long now = System.currentTimeMillis();
//    if (now - then > 100L) {
//      logger.info("getStartupInfo took " + (now - then) + " millis to get startup info.");
//    }
//    logger.debug("getStartupInfo sending " + startupInfo);
    return startupInfo;
  }

 /**
   * @param userExercise
   * @see mitll.langtest.client.custom.dialog.NewUserExercise#editItem
   */
  @Override
  public void editItem(CommonExercise userExercise, boolean keepAudio) throws DominoSessionException {
    getUserIDFromSessionOrDB();
    db.editItem(userExercise, keepAudio);
  }
  /*

  *//**
   * @param userExercise
   * @param mediaDir
   * @param typeOrder
   * @see mitll.langtest.server.database.DatabaseImpl#editItem
   * @see mitll.langtest.client.custom.dialog.NewUserExercise#editItem
   *//*
  @Override
  public void editItem(CommonExercise userExercise, String mediaDir, Collection<String> typeOrder) {
    fixAudioPaths(userExercise, true, mediaDir);
    db.getUserExerciseDAO().update(userExercise, false, typeOrder);
  }


  *//**
   * TODO : Why is this needed?
   * <p>
   * Remember to copy the audio from the posted location to a more permanent location.
   * <p>
   * If it's already under a media directory -- don't change it.
   *
   * @param userExercise
   * @param overwrite
   * @param mediaDir
   * @seex IUserListManager#newExercise
   * @see UserListManager#editItem
   *//*
  private void fixAudioPaths(CommonExercise userExercise, boolean overwrite, String mediaDir) {
    AudioAttribute regularSpeed = userExercise.getRegularSpeed();
    if (regularSpeed == null) {
      logger.info("fixAudioPaths no audio yet for " + userExercise);
      return;
    }
    long now = System.currentTimeMillis();
    logger.info("fixAudioPaths : checking regular '" + regularSpeed.getAudioRef() + "' against '" + mediaDir + "'");

    // String foreignLanguage = userExercise.getForeignLanguage();
    int id = userExercise.getID();
    int projectID = userExercise.getProjectID();

    if (!regularSpeed.getAudioRef().contains(mediaDir)) {
      fixAudioPathOfAttribute(userExercise, overwrite, regularSpeed, now, id, projectID, FAST);
      logger.info("fixAudioPaths : for " + userExercise.getOldID() + " fast is " + regularSpeed.getAudioRef());
    }

    AudioAttribute slowSpeed = userExercise.getSlowSpeed();
    if (slowSpeed != null && !slowSpeed.getAudioRef().isEmpty() &&
        !slowSpeed.getAudioRef().contains(mediaDir)) {
      fixAudioPathOfAttribute(userExercise, overwrite, slowSpeed, now, id, projectID, SLOW);
    }
  }

  *//**
   * @param userExercise
   * @param overwrite
   * @param regularSpeed
   * @param now
   * @param id
   * @param projectID
   * @param prefix
   *//*
  private void fixAudioPathOfAttribute(CommonExercise userExercise,
                                       boolean overwrite,
                                       AudioAttribute regularSpeed,
                                       long now,
                                       int id,
                                       int projectID,
                                       String prefix) {
    File fileRef = pathHelper.getAbsoluteAudioFile(regularSpeed.getAudioRef());

    String fast = prefix + "_" + now + "_by_" + userExercise.getCreator() + ".wav";
    String artist = regularSpeed.getUser().getUserID();
    String refAudio = getRefAudioPath(
        projectID,
        id,
        fileRef,
        fast,
        overwrite,
        new TrackInfo(userExercise.getForeignLanguage(), artist, userExercise.getEnglish(), ""));
    regularSpeed.setAudioRef(refAudio);
  }

  *//**
   * Copying audio from initial recording location to new location.
   * <p>
   * Also normalizes the audio level.
   *
   * @param projid
   * @param id
   * @param fileRef
   * @param destFileName
   * @param overwrite
   * @param trackInfo
   * @return new, permanent audio path
   * @see #fixAudioPaths
   *//*
  private String getRefAudioPath(int projid,
                                 int id,
                                 File fileRef,
                                 String destFileName,
                                 boolean overwrite,
                                 TrackInfo trackInfo) {
    //Database database = db.getUserDAO().getDatabase();
    ServerProperties serverProps = db.getServerProps();


    Project project = getProject(projid);
    return new PathWriter(serverProps).getPermanentAudioPath(
        fileRef,
        destFileName,
        overwrite,
        project.getLanguage(),
        id,
        serverProps,
        trackInfo);
  }*/
}