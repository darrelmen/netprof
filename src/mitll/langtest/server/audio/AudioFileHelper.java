package mitll.langtest.server.audio;

import com.google.common.io.Files;
import mitll.langtest.client.AudioTag;
import mitll.langtest.server.LangTestDatabaseImpl;
import mitll.langtest.server.PathHelper;
import mitll.langtest.server.ServerProperties;
import mitll.langtest.server.autocrt.AutoCRT;
import mitll.langtest.server.database.DatabaseImpl;
import mitll.langtest.server.scoring.ASRScoring;
import mitll.langtest.server.scoring.AutoCRTScoring;
import mitll.langtest.server.scoring.SmallVocabDecoder;
import mitll.langtest.shared.AudioAnswer;
import mitll.langtest.shared.Exercise;
import mitll.langtest.shared.scoring.PretestScore;
import org.apache.log4j.Logger;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Created with IntelliJ IDEA.
 * User: GO22670
 * Date: 8/8/13
 * Time: 5:08 PM
 * To change this template use File | Settings | File Templates.
 */
public class AudioFileHelper {
  private static Logger logger = Logger.getLogger(AudioFileHelper.class);
  private PathHelper pathHelper;
  private ServerProperties serverProps;
  private ASRScoring asrScoring;
  private AutoCRT autoCRT;
  private DatabaseImpl db;
  private LangTestDatabaseImpl langTestDatabase;

  public AudioFileHelper(PathHelper pathHelper, ServerProperties serverProperties, DatabaseImpl db,
                         LangTestDatabaseImpl langTestDatabase) {
    this.pathHelper = pathHelper;
    this.serverProps = serverProperties;
    this.db = db;
    this.langTestDatabase = langTestDatabase;
  }

  public boolean checkLTS(String foreignLanguagePhrase) { return asrScoring.checkLTS(foreignLanguagePhrase); }
  public SmallVocabDecoder getSmallVocabDecoder() {
    makeASRScoring();
    return asrScoring.getSmallVocabDecoder();
  }

  /**
   * Record an answer entry in the database.<br></br>
   * Write the posted data to a wav and an mp3 file (since all the browser audio works with mp3).
   *
   * Client references:
   * @see mitll.langtest.client.scoring.PostAudioRecordButton#stopRecording()
   * @see mitll.langtest.client.recorder.RecordButtonPanel#stopRecording()
   * @see LangTestDatabaseImpl#writeAudioFile
   * @param base64EncodedString generated by flash on the client
   * @param plan which set of exercises
   * @param exercise
   * @param exercise1 exercise within the plan
   * @param questionID question within the exercise
   * @param user answering the question
   * @param reqid request id from the client, so it can potentially throw away out of order responses
   * @param flq was the prompt a foreign language query
   * @param audioType regular or fast then slow audio recording
   * @param doFlashcard
   * @param recordInResults         @return URL to audio on server and if audio is valid (not too short, etc.)
   */
  public AudioAnswer writeAudioFile(String base64EncodedString, String plan, String exercise, Exercise exercise1, int questionID,
                                    int user, int reqid, boolean flq, String audioType, boolean doFlashcard,
                                    boolean recordInResults
  ) {
    String wavPath = pathHelper.getLocalPathToAnswer(plan, exercise, questionID, user);
    File file = pathHelper.getAbsoluteFile(wavPath);

    AudioCheck.ValidityAndDur validity = new AudioConversion().convertBase64ToAudioFiles(base64EncodedString, file);
    boolean isValid = validity.validity == AudioAnswer.Validity.OK;
    if (!isValid) {
      logger.warn("got invalid audio file (" + validity +
        ") user = " + user + " exercise " + exercise +
        " question " + questionID + " file " + file.getAbsolutePath());
    }

    String url = pathHelper.ensureForwardSlashes(wavPath);

    AudioAnswer answer = (isValid) ?
      getAudioAnswer(exercise, exercise1, questionID, user, reqid, file, validity, url, doFlashcard) :
      new AudioAnswer(url, validity.validity, reqid, validity.durationInMillis);

    if (recordInResults) {
      long answerID = db.addAudioAnswer(user, plan, exercise, questionID, file.getPath(),
        isValid, flq, true, audioType, validity.durationInMillis, answer.isCorrect(), (float) answer.getScore());
      answer.setResultID(answerID);
    }
    logger.info("writeAudioFile answer " + answer);
    return answer;
  }


  /**
   * @see mitll.langtest.client.scoring.ScoringAudioPanel#scoreAudio(String, long, String, mitll.langtest.client.scoring.AudioPanel.ImageAndCheck, mitll.langtest.client.scoring.AudioPanel.ImageAndCheck, int, int, int)
   * @param reqid
   * @param testAudioFile
   * @param sentence
   * @param width
   * @param height
   * @param useScoreToColorBkg
   * @return
   */
  public PretestScore getASRScoreForAudio(int reqid, String testAudioFile, String sentence,
                                          int width, int height, boolean useScoreToColorBkg) {
    return getASRScoreForAudio(reqid, testAudioFile, sentence, width, height, useScoreToColorBkg,
      false, Files.createTempDir().getAbsolutePath(), serverProps.useScoreCache());
  }

  /**
   * Get score when doing autoCRT on an audio file.
   * @see AutoCRT#getAutoCRTDecodeOutput
   * @see AutoCRT#getFlashcardAnswer
   * @param testAudioFile audio file to score
   * @param lmSentences to look for in the audio
   * @return PretestScore for audio
   */
  public PretestScore getASRScoreForAudio(File testAudioFile, Collection<String> lmSentences) {
    String tmpDir = Files.createTempDir().getAbsolutePath();
    String slfFile = createSLFFile(lmSentences, tmpDir);
    if (!new File(slfFile).exists()) {
      logger.error("couldn't make slf file?");
      return new PretestScore();
    } else {
      makeASRScoring();
      List<String> unk = new ArrayList<String>();
      unk.add(SLFFile.UNKNOWN_MODEL); // if  you don't include this dcodr will say : ERROR: word UNKNOWNMODEL is not in the dictionary!
      String vocab = asrScoring.getUsedTokens(lmSentences, unk);
      logger.debug("getASRScoreForAudio : vocab " + vocab);
      return getASRScoreForAudio(0, testAudioFile.getPath(), vocab, 128, 128, false, true, tmpDir, serverProps.useScoreCache());
    }
  }

  /**
   * @see mitll.langtest.client.flashcard.TextCRTFlashcard#getAnswerAndRecordButtonRow(mitll.langtest.shared.Exercise, mitll.langtest.client.LangTestDatabaseAsync, mitll.langtest.client.exercise.ExerciseController)
   * @see LangTestDatabaseImpl#getScoreForAnswer
   * @param e
   * @param questionID
   * @param answer
   * @return
   */
  public double getScoreForAnswer(Exercise e, int questionID, String answer) {
    return autoCRT.getScoreForExercise(e, questionID, answer);
  }

  private String createSLFFile(Collection<String> lmSentences, String tmpDir) {
    return new SLFFile().createSimpleSLFFile(lmSentences, tmpDir);
  }

  /**
   * @see mitll.langtest.server.LangTestDatabaseImpl#getValidPhrases(java.util.Collection)
   * @param phrases
   * @return
   */
  public Collection<String> getValidPhrases(Collection<String> phrases) {
    makeASRScoring(); // TODO : evil
    return asrScoring.getValidPhrases(phrases);
  }

  /**
   * For now, we don't use a ref audio file, since we aren't comparing against a ref audio file with the DTW/sv pathway.
   *
   * @see #getASRScoreForAudio(int, String, String, int, int, boolean)
   * @see mitll.langtest.server.scoring.AutoCRTScoring#getASRScoreForAudio
   * @see mitll.langtest.client.scoring.ScoringAudioPanel#scoreAudio(String, long, String, mitll.langtest.client.scoring.AudioPanel.ImageAndCheck, mitll.langtest.client.scoring.AudioPanel.ImageAndCheck, int, int, int)
   * @param reqid
   * @param testAudioFile
   * @param sentence empty string when using lmSentences non empty and vice-versa
   * @param width image dim
   * @param height  image dim
   * @param useScoreToColorBkg
   * @param decode
   * @param tmpDir
   * @param useCache
   * @return PretestScore
   **/
  public PretestScore getASRScoreForAudio(int reqid, String testAudioFile, String sentence,
                                           int width, int height, boolean useScoreToColorBkg,
                                           boolean decode, String tmpDir, boolean useCache) {
    logger.info("getASRScoreForAudio scoring " + testAudioFile + " with sentence '" + sentence + "' req# " + reqid);

    makeASRScoring();
    if (testAudioFile == null) {
      return new PretestScore(); // very defensive
    }
    testAudioFile = dealWithMP3Audio(testAudioFile);
    if (!new File(testAudioFile).exists()) {
      return new PretestScore();
    }

    String installPath = pathHelper.getInstallPath();

    DirAndName testDirAndName = new DirAndName(testAudioFile, installPath).invoke();
    String testAudioName = testDirAndName.getName();
    String testAudioDir = testDirAndName.getDir();

    if (serverProps.getLanguage().equalsIgnoreCase("English")) {
      sentence = sentence.toUpperCase();  // hack for English
    }
    PretestScore pretestScore = asrScoring.scoreRepeat(
      testAudioDir, removeSuffix(testAudioName),
      sentence,
      pathHelper.getImageOutDir(), width, height, useScoreToColorBkg, decode, tmpDir, useCache);
    pretestScore.setReqid(reqid);

    return pretestScore;
  }

  /**
   * Just for testing!
   * @see mitll.langtest.server.RecoTest#isMatch
   *
   * @param e
   * @param audioFile
   * @param answer
   */
  public void getFlashcardAnswer(Exercise e, File audioFile, AudioAnswer answer) {
    this.autoCRT.getFlashcardAnswer(e, audioFile, answer);
  }

  private String removeSuffix(String audioFile) {
    return audioFile.substring(0, audioFile.length() - ("." + AudioTag.COMPRESSED_TYPE).length());
  }

  /**
   * @see #getASRScoreForAudio(int, String, String, int, int, boolean, boolean, String, boolean)
   * @param testAudioFile
   * @return
   */
  private String dealWithMP3Audio(String testAudioFile) {
    if (testAudioFile.endsWith("." +
        AudioTag.COMPRESSED_TYPE)) {
      String noSuffix = removeSuffix(testAudioFile);
      String wavFile = noSuffix +".wav";
      File test = pathHelper.getAbsoluteFile(wavFile);
      if (!test.exists()) {
        logger.warn("expecting audio file with wav extension, but didn't find "  +test.getAbsolutePath());
      }
      return test.exists() ? test.getAbsolutePath() :  getWavForMP3(testAudioFile);
    }
    else {
      return testAudioFile;
    }
  }

  /**
   * @see #dealWithMP3Audio(String)
   * @see mitll.langtest.server.LangTestDatabaseImpl#getImageForAudioFile(int, String, String, int, int)
   * @param audioFile
   * @return
   */
  public String getWavForMP3(String audioFile) {
    return getWavForMP3(audioFile, pathHelper.getInstallPath());
  }

  /**
   * Ultimately does lame --decode from.mp3 to.wav
   *
   * Worries about converting from either a relative path to an absolute path (given the webapp install location)
   * or if audioFile is a URL, converting it to a relative path before making an absolute path.
   *
   * Gotta be a better way...
   *
   * @see #getWavForMP3(String)
   * @param audioFile to convert
   * @return
   */
  private String getWavForMP3(String audioFile, String installPath) {
    assert(audioFile.endsWith(".mp3"));
    String absolutePath = pathHelper.getAbsolute(installPath, audioFile).getAbsolutePath();

    if (!new File(absolutePath).exists())
      logger.error("getWavForMP3 : expecting file at " + absolutePath);
    else {
      AudioConversion audioConversion = new AudioConversion();
      File file = audioConversion.convertMP3ToWav(absolutePath);
      if (file.exists()) {
        String orig = audioFile;
        audioFile = file.getAbsolutePath();
        logger.info("\n\ngetWavForMP3 : from " + orig + " wrote to " + file + " or " + audioFile);
      }
      else {
        logger.error("getImageForAudioFile : can't find " + file.getAbsolutePath());
      }
    }
    assert(audioFile.endsWith(".wav"));
    return audioFile;
  }

  /**
   * @see #writeAudioFile
   * @param exerciseID
   * @param questionID
   * @param user
   * @param reqid
   * @param file
   * @param validity
   * @param url
   * @param doFlashcard
   * @return
   */
  private AudioAnswer getAudioAnswer(String exerciseID, Exercise exercise, int questionID, int user, int reqid,
                                     File file, AudioCheck.ValidityAndDur validity, String url, boolean doFlashcard
  ) {
    AudioAnswer audioAnswer = new AudioAnswer(url, validity.validity, reqid, validity.durationInMillis);
    if (serverProps.isFlashcard()|| doFlashcard) {
      makeASRScoring();
      if (serverProps.isAutoCRT()) {
        autoCRT.getAutoCRTDecodeOutput(exerciseID, questionID, exercise, file, audioAnswer);
      } else {
        autoCRT.getFlashcardAnswer(exercise, file, audioAnswer);
      }
      db.updateFlashcardState(user, exerciseID, audioAnswer.isCorrect());
      return audioAnswer;
    } else if (serverProps.isAutoCRT() && !exercise.isPromptInEnglish()) { // TODO : hack -- don't do CRT on english
      autoCRT.getAutoCRTDecodeOutput(exerciseID, questionID, exercise, file, audioAnswer);
    }
    return audioAnswer;
  }

  private void makeASRScoring() {
    if (asrScoring == null) {
      asrScoring = new ASRScoring(pathHelper.getInstallPath(), serverProps.getProperties(), langTestDatabase); // lazy eval since reads in the dictionary
    }
  }

  /**
   * @see mitll.langtest.server.LangTestDatabaseImpl#makeAutoCRT()
   * @param relativeConfigDir
   * @param crtScoring
   * @param studentAnswersDB
   * @param langTestDatabase
   */
  public void makeAutoCRT(String relativeConfigDir, AutoCRTScoring crtScoring, DatabaseImpl studentAnswersDB,
                          LangTestDatabaseImpl langTestDatabase) {
    if (autoCRT == null) {
      DatabaseImpl exportDB = serverProps.isAutoCRT() ? studentAnswersDB : db;
      if (serverProps.isAutoCRT()) {
        langTestDatabase.setInstallPath(serverProps.getUseFile(), exportDB);
        exportDB.getExercises();
      }
      autoCRT = new AutoCRT(exportDB.getExport(), crtScoring, pathHelper.getInstallPath(), relativeConfigDir,
        serverProps.getMinPronScore());
      if (serverProps.isAutoCRT()) {
        autoCRT.makeClassifier();
      }
    }
  }
  /**
   * @see #getASRScoreForAudio(int, String, String, int, int, boolean, boolean, String, boolean)
   */
  private static class DirAndName {
    private final String testAudioFile;
    private final String installPath;
    private String testAudioName;
    private String testAudioDir;

    public DirAndName(String testAudioFile, String installPath) {
      this.testAudioFile = testAudioFile;
      this.installPath = installPath;
    }

    public String getName() {
      return testAudioName;
    }

    public String getDir() { return testAudioDir; }

    public DirAndName invoke() {
      File testAudio = new File(testAudioFile);
      testAudioName = testAudio.getName();
      if (testAudio.getParent().startsWith(installPath)) {
        testAudioDir = testAudio.getParent().substring(installPath.length());
      }
      else {
        testAudioDir = testAudio.getParent();
      }

      return this;
    }
  }
}
