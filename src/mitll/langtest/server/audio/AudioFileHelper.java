package mitll.langtest.server.audio;

import com.google.common.io.Files;
import mitll.langtest.client.AudioTag;
import mitll.langtest.server.LangTestDatabaseImpl;
import mitll.langtest.server.PathHelper;
import mitll.langtest.server.ScoreServlet;
import mitll.langtest.server.ServerProperties;
import mitll.langtest.server.autocrt.AutoCRT;
import mitll.langtest.server.database.DatabaseImpl;
import mitll.langtest.server.database.Export;
import mitll.langtest.server.scoring.ASRScoring;
import mitll.langtest.server.scoring.AutoCRTScoring;
import mitll.langtest.server.scoring.SmallVocabDecoder;
import mitll.langtest.shared.AudioAnswer;
import mitll.langtest.shared.CommonExercise;
import mitll.langtest.shared.scoring.PretestScore;
import org.apache.log4j.Logger;

import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * Created with IntelliJ IDEA.
 * User: GO22670
 * Date: 8/8/13
 * Time: 5:08 PM
 * To change this template use File | Settings | File Templates.
 */
public class AudioFileHelper {
  private static final Logger logger = Logger.getLogger(AudioFileHelper.class);

  private final PathHelper pathHelper;
  private final ServerProperties serverProps;
  private ASRScoring asrScoring;
  private AutoCRT autoCRT;
  private final DatabaseImpl db;
  private final LangTestDatabaseImpl langTestDatabase;

  /**
   * @see mitll.langtest.server.ScoreServlet#getAudioFileHelper()
   * @param pathHelper
   * @param serverProperties
   * @param db
   * @param langTestDatabase
   */
  public AudioFileHelper(PathHelper pathHelper, ServerProperties serverProperties, DatabaseImpl db,
                         LangTestDatabaseImpl langTestDatabase) {
    this.pathHelper = pathHelper;
    this.serverProps = serverProperties;
    this.db = db;
    this.langTestDatabase = langTestDatabase;
  }

  /**
   * @see mitll.langtest.server.LangTestDatabaseImpl#isValidForeignPhrase(String)
   * @param foreignLanguagePhrase
   * @return
   */
  public boolean checkLTS(String foreignLanguagePhrase) {
    makeASRScoring();
    return asrScoring.checkLTS(foreignLanguagePhrase);
  }

  public SmallVocabDecoder getSmallVocabDecoder() {
    makeASRScoring();
    return asrScoring.getSmallVocabDecoder();
  }

  /**
   * Record an answer entry in the database.<br></br>
   * Write the posted data to a wav and an mp3 file (since all the browser audio works with mp3).
   *
   * Client references:
   * @see mitll.langtest.client.scoring.PostAudioRecordButton#stopRecording()
   * @see mitll.langtest.client.recorder.RecordButtonPanel#stopRecording()
   * @see LangTestDatabaseImpl#writeAudioFile
   * @param base64EncodedString generated by flash on the client
   * @param plan which set of exercises
   * @param exerciseID
   * @param exercise1 exerciseID within the plan
   * @param questionID question within the exerciseID
   * @param user answering the question
   * @param reqid request id from the client, so it can potentially throw away out of order responses
   * @param flq was the prompt a foreign language query
   * @param audioType regular or fast then slow audio recording
   * @param doFlashcard
   * @param recordInResults
   * @param recordedWithFlash
   * @return URL to audio on server and if audio is valid (not too short, etc.)
   */
  public AudioAnswer writeAudioFile(String base64EncodedString, String plan, String exerciseID, CommonExercise exercise1, int questionID,
                                    int user, int reqid, boolean flq, String audioType, boolean doFlashcard,
                                    boolean recordInResults, boolean recordedWithFlash) {
    String wavPath = pathHelper.getLocalPathToAnswer(plan, exerciseID, questionID, user);
    File file = pathHelper.getAbsoluteFile(wavPath);

    AudioCheck.ValidityAndDur validity = new AudioConversion().convertBase64ToAudioFiles(base64EncodedString, file);
    boolean isValid = validity.validity == AudioAnswer.Validity.OK || (serverProps.isQuietAudioOK() && validity.validity == AudioAnswer.Validity.TOO_QUIET);
    if (!isValid) {
      logger.warn("got invalid audio file (" + validity +
        ") user = " + user + " exerciseID " + exerciseID +
        " question " + questionID + " file " + file.getAbsolutePath());
    }

    String url = pathHelper.ensureForwardSlashes(wavPath);

    AudioAnswer answer = (isValid && !serverProps.isNoModel()) ?
      getAudioAnswer(
        exercise1,
        reqid, file, validity, url, doFlashcard) :
      new AudioAnswer(url, validity.validity, reqid, validity.durationInMillis);

    if (recordInResults) {
      long answerID = db.addAudioAnswer(user, plan, exerciseID, questionID, file.getPath(),
        isValid, flq, true, audioType, validity.durationInMillis, answer.isCorrect(), (float) answer.getScore(), recordedWithFlash);
      answer.setResultID(answerID);
    }
    logger.debug("writeAudioFile answer " + answer);
    return answer;
  }

  /**
   * @see mitll.langtest.server.LangTestDatabaseImpl#getAlignment(String, String, String, int)
   * @param base64EncodedString
   * @param textToAlign
   * @param identifier
   * @param reqid
   * @return
   */
  public AudioAnswer getAlignment(String base64EncodedString, String textToAlign, String identifier, int reqid) {
    String wavPath = pathHelper.getWavPathUnder("postedAudio");
    File file = pathHelper.getAbsoluteFile(wavPath);

    AudioCheck.ValidityAndDur validity = new AudioConversion().convertBase64ToAudioFiles(base64EncodedString, file);
    boolean isValid = validity.validity == AudioAnswer.Validity.OK;
    AudioAnswer audioAnswer = new AudioAnswer(pathHelper.ensureForwardSlashes(wavPath), validity.validity, reqid, validity.durationInMillis);

    logger.debug("writing to " + file.getAbsolutePath() + " answer " + audioAnswer);

    if (isValid) {
      PretestScore asrScoreForAudio = getASRScoreForAudio(reqid, file.getAbsolutePath(), textToAlign, -1, -1, false,
          false, Files.createTempDir().getAbsolutePath(), serverProps.useScoreCache(), identifier);

      audioAnswer.setPretestScore(asrScoreForAudio);
    } else {
      logger.warn("got invalid audio file (" + validity + ") identifier " + identifier + " file " + file.getAbsolutePath());
    }

    return audioAnswer;
  }

  /**
   * Get score when doing autoCRT on an audio file.
   *
   * TODO : why even generate images here???
   *
   * @see AutoCRT#getAutoCRTDecodeOutput
   * @see AutoCRT#getFlashcardAnswer
   * @see mitll.langtest.server.LangTestDatabaseImpl#getASRScoreForAudio(java.io.File, java.util.Collection)
   * @param testAudioFile audio file to score
   * @param lmSentences to look for in the audio
   * @return PretestScore for audio
   */
  public PretestScore getASRScoreForAudio(File testAudioFile, Collection<String> lmSentences) {
    String tmpDir = Files.createTempDir().getAbsolutePath();
    String slfFile = createSLFFile(lmSentences, tmpDir);
    if (!new File(slfFile).exists()) {
      logger.error("couldn't make slf file?");
      return new PretestScore();
    } else {
      makeASRScoring();
      List<String> unk = new ArrayList<String>();
      unk.add(SLFFile.UNKNOWN_MODEL); // if  you don't include this dcodr will say : ERROR: word UNKNOWNMODEL is not in the dictionary!
      String vocab = asrScoring.getUsedTokens(lmSentences, unk);
      //logger.debug("getASRScoreForAudio : vocab " + vocab);
      return getASRScoreForAudio(0, testAudioFile.getPath(), vocab, 128, 128, false, true, tmpDir, serverProps.useScoreCache(), "");
    }
  }

  private String createSLFFile(Collection<String> lmSentences, String tmpDir) {
    return new SLFFile().createSimpleSLFFile(lmSentences, tmpDir);
  }

  /**
   * @see mitll.langtest.server.LangTestDatabaseImpl#getValidPhrases(java.util.Collection)
   * @param phrases
   * @return
   */
  public Collection<String> getValidPhrases(Collection<String> phrases) {
    makeASRScoring(); // TODO : evil
    return asrScoring.getValidPhrases(phrases);
  }

  /**
   * For now, we don't use a ref audio file, since we aren't comparing against a ref audio file with the DTW/sv pathway.
   *
   * @seex #getASRScoreForAudio(int, String, String, int, int, boolean)
   * @see mitll.langtest.server.scoring.AutoCRTScoring#getASRScoreForAudio
   * @see mitll.langtest.client.scoring.ScoringAudioPanel#scoreAudio(String, long, String, mitll.langtest.client.scoring.AudioPanel.ImageAndCheck, mitll.langtest.client.scoring.AudioPanel.ImageAndCheck, int, int, int)
   * @param reqid
   * @param testAudioFile
   * @param sentence empty string when using lmSentences non empty and vice-versa
   * @param width image dim
   * @param height  image dim
   * @param useScoreToColorBkg
   * @param decode
   * @param tmpDir
   * @param useCache
   * @param prefix
   * @return PretestScore
   **/
  public PretestScore getASRScoreForAudio(int reqid, String testAudioFile, String sentence,
                                          int width, int height, boolean useScoreToColorBkg,
                                          boolean decode, String tmpDir, boolean useCache, String prefix) {
    logger.debug("getASRScoreForAudio (" + serverProps.getLanguage() + ")" +
        " scoring " + testAudioFile + " with sentence '" + sentence + "' req# " + reqid);

    makeASRScoring();
    if (testAudioFile == null) {
      return new PretestScore(); // very defensive
    }
    testAudioFile = dealWithMP3Audio(testAudioFile);
    if (!new File(testAudioFile).exists()) {
      return new PretestScore();
    }

    String installPath = pathHelper.getInstallPath();

    DirAndName testDirAndName = new DirAndName(testAudioFile, installPath).invoke();
    String testAudioName = testDirAndName.getName();
    String testAudioDir = testDirAndName.getDir();

    if (serverProps.getLanguage().equalsIgnoreCase("English")) {
      sentence = sentence.toUpperCase();  // hack for English
    }
    PretestScore pretestScore = asrScoring.scoreRepeat(
      testAudioDir, removeSuffix(testAudioName),
      sentence,
      pathHelper.getImageOutDir(), width, height, useScoreToColorBkg, decode, tmpDir, useCache, prefix);
    pretestScore.setReqid(reqid);

    return pretestScore;
  }

  /**
   * Just for testing!
   * @see mitll.langtest.server.RecoTest#isMatch
   *
   * @param e
   * @param audioFile
   * @param answer
   */
  public void getFlashcardAnswer(CommonExercise e, File audioFile, AudioAnswer answer) {
    this.autoCRT.getFlashcardAnswer(e, audioFile, answer);
  }

  private String removeSuffix(String audioFile) {
    return audioFile.substring(0, audioFile.length() - ("." + AudioTag.COMPRESSED_TYPE).length());
  }

  /**
   * @see #getASRScoreForAudio(int, String, String, int, int, boolean, boolean, String, boolean, String)
   * @param testAudioFile
   * @return
   */
  private String dealWithMP3Audio(String testAudioFile) {
    if (testAudioFile.endsWith("." + AudioTag.COMPRESSED_TYPE)) {
      String noSuffix = removeSuffix(testAudioFile);
      String wavFile = noSuffix +".wav";
      File test = pathHelper.getAbsoluteFile(wavFile);
      if (!test.exists()) {
        logger.warn("expecting audio file with wav extension, but didn't find "  +test.getAbsolutePath());
      }
      return test.exists() ? test.getAbsolutePath() :  getWavForMP3(testAudioFile);
    }
    else {
      return testAudioFile;
    }
  }

  /**
   * @see #dealWithMP3Audio(String)
   * @see mitll.langtest.server.LangTestDatabaseImpl#getImageForAudioFile
   * @param audioFile
   * @return
   */
  public String getWavForMP3(String audioFile) {
    return getWavForMP3(audioFile, pathHelper.getInstallPath());
  }

  /**
   * Ultimately does lame --decode from.mp3 to.wav
   *
   * Worries about converting from either a relative path to an absolute path (given the webapp install location)
   * or if audioFile is a URL, converting it to a relative path before making an absolute path.
   *
   * Gotta be a better way...
   *
   * @see #getWavForMP3(String)
   * @param audioFile to convert
   * @return
   */
  private String getWavForMP3(String audioFile, String installPath) {
    assert(audioFile.endsWith(".mp3"));
    String absolutePath = pathHelper.getAbsolute(installPath, audioFile).getAbsolutePath();

    if (!new File(absolutePath).exists())
      logger.error("getWavForMP3 : expecting file at " + absolutePath);
    else {
      AudioConversion audioConversion = new AudioConversion();
      File file = audioConversion.convertMP3ToWav(absolutePath);
      if (file.exists()) {
        String orig = audioFile;
        audioFile = file.getAbsolutePath();
        logger.info("\n\ngetWavForMP3 : from " + orig + " wrote to " + file + " or " + audioFile);
      }
      else {
        logger.error("getImageForAudioFile : can't find " + file.getAbsolutePath());
      }
    }
    assert(audioFile.endsWith(".wav"));
    return audioFile;
  }

  /**
   * @see #writeAudioFile
   * @param reqid
   * @param file
   * @param validity
   * @param url
   * @param doFlashcard
   * @return
   */
  private AudioAnswer getAudioAnswer(CommonExercise exercise,
                                     int reqid,
                                     File file, AudioCheck.ValidityAndDur validity, String url, boolean doFlashcard) {
    AudioAnswer audioAnswer = new AudioAnswer(url, validity.validity, reqid, validity.durationInMillis);
    if (serverProps.isFlashcard() || doFlashcard) {
      makeASRScoring();
      autoCRT.getFlashcardAnswer(exercise, file, audioAnswer);
      return audioAnswer;
    }
    return audioAnswer;
  }

  /**
   * @see mitll.langtest.server.ScoreServlet#getFlashcardScore(AudioFileHelper, java.io.File, String)
   * @param file
   * @param wordOrPhrase
   * @return
   */
  public ScoreAndAnswer getFlashcardAnswer(File file, String wordOrPhrase) {
    makeASRScoring();
    AudioAnswer audioAnswer = new AudioAnswer();
    PretestScore flashcardAnswer = autoCRT.getFlashcardAnswer(file, wordOrPhrase, audioAnswer);
    return new ScoreAndAnswer(flashcardAnswer, audioAnswer);
  }

  public static class ScoreAndAnswer {
    public PretestScore score;
    public AudioAnswer answer;
    public ScoreAndAnswer(PretestScore score, AudioAnswer answer) {
      this.score = score;
      this.answer = answer;
    }
  }

  private void makeASRScoring() {
    if (asrScoring == null) {
      asrScoring = new ASRScoring(pathHelper.getInstallPath(), serverProps.getProperties(), langTestDatabase); // lazy eval since reads in the dictionary
    }
  }

  /**
   * @see mitll.langtest.server.LangTestDatabaseImpl#makeAutoCRT()
   * @param relativeConfigDir
   * @param crtScoring
   * @paramx studentAnswersDB
   * @paramx langTestDatabase
   */
  public void makeAutoCRT(String relativeConfigDir, AutoCRTScoring crtScoring
  //  , DatabaseImpl studentAnswersDB,
  //                        LangTestDatabaseImpl langTestDatabase
  ) {
    if (autoCRT == null) {
/*      DatabaseImpl exportDB = serverProps.isAutoCRT() ? studentAnswersDB : db;
      if (serverProps.isAutoCRT()) {
        langTestDatabase.setInstallPath(serverProps.getUseFile(), exportDB);
        exportDB.getExercises();
      }*/
      Export export = db.getExport();
      autoCRT = new AutoCRT(export, crtScoring, pathHelper.getInstallPath(), relativeConfigDir,
        serverProps.getMinPronScore());
      if (serverProps.isAutoCRT() && serverProps.isIncludeFeedback()) {
        autoCRT.makeClassifier();
      }
    }
  }
  /**
   * @see #getASRScoreForAudio(int, String, String, int, int, boolean, boolean, String, boolean, String)
   */
  private static class DirAndName {
    private final String testAudioFile;
    private final String installPath;
    private String testAudioName;
    private String testAudioDir;

    public DirAndName(String testAudioFile, String installPath) {
      this.testAudioFile = testAudioFile;
      this.installPath = installPath;
    }

    public String getName() {
      return testAudioName;
    }

    public String getDir() { return testAudioDir; }

    public DirAndName invoke() {
      File testAudio = new File(testAudioFile);
      testAudioName = testAudio.getName();
      if (testAudio.getParent().startsWith(installPath)) {
        testAudioDir = testAudio.getParent().substring(installPath.length());
      }
      else {
        testAudioDir = testAudio.getParent();
      }

      return this;
    }
  }
}
